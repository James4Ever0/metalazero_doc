(setq lexical-binding t)
(defun voidme ()
  (interactive)
(require 'package)
(package-initialize)
; this is a huge mistake.
;does not recognize the scene?
(find-file "lsp.sh")
(print (current-buffer))
(print (buffer-substring-no-properties 1 (buffer-size)))
(setq lsp-idle-delay 0)
(next-line)
;(completion-at-point)
;(call-interactively (completion-at-point))
(lsp)
;(print (lsp-completion-at-point))
;(setq vna (lsp-completion-at-point))
;(print lsp-completion--cache)
;(print (type-of vna))
;void?
;(completion-at-point)
;(print (completion--capf-wrapper completion-at-point-functions 'all))
;(print completion-at-point-functions)
;(print (type-of completion-at-point-functions))
;(lsp-describe-session)
(setq completion-at-point-functions (cons 'lsp-completion-at-point '()))
(print completion-at-point-functions)
;works but hmm...
(run-at-time "5 sec" nil
'(lambda () (completion-at-point)
(print lsp-completion--cache)))
;(print completion-in-region--data)
;(sh-completion-at-point-function comint-completion-at-point t)
;override this shit.
;cons.
;(print (car vna))
;(print (cdr vna))
;(print (funcall (car (cdr (cdr vna))) 24))
;(print pcol)
;(print plist)
;(lsp-completion--clear-cache nil t)
;(add-hook 'after-init-hook #'voidme)
;(kill-emacs)
)
(run-at-time "1 sec" nil 'voidme)
;(add-hook 'after-init-hook #'voidme)
;(add-hook 'emacs-startup-hook #'voidme)
; after initialization.
;(completion-at-point-functions)
;(print (buffer-list))
;(switch-to-buffer "*Completions*")

;(print (current-buffer))
;(print (buffer-substring-no-properties 1 (buffer-size)))
;(delete-all-overlays)
;(print (buffer-string))
(defun minibuffer-input-provider (inputs)
  (let ((hook (make-symbol "hook")))
    (fset hook (lambda ()
                 (remove-hook 'post-command-hook hook)
                 (when inputs
                   (when (= 0 (minibuffer-depth))
                     (error "Too many inputs"))
                   (when (cdr inputs)
                     (add-hook 'post-command-hook hook))
                   (insert (pop inputs))
                   (exit-minibuffer))))
    (add-hook 'post-command-hook hook)))

(defmacro with-minibuffer-input (form &rest inputs)
  (declare (indent 1))
  `(minibuffer-with-setup-hook
       (lambda ()
         (minibuffer-input-provider ',inputs))
     ,form))

;(run-with-timer 1 nil 'insert "filename.tex")
;(run-with-timer 2 nil 'execute-kbd-macro (kbd "RET"))

;(with-minibuffer-input (call-interactively 'eval-expression) "(print 'hello)")
;cannot answer this.
